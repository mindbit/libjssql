/* SPDX-License-Identifier: MIT */

#define _GNU_SOURCE
#include <jsmisc.h>
#include <libpq-fe.h>

#include "jspgsql.h"
#include "jssql.h"
#include "jscommon.h"

struct agk_columns {
	uint32_t len;
	int *indexes;
	char **names;
};

struct statement {
	char *command;
	int type;	//this can be removed because we can identify the type
			//of statement using p_len

	// parameters
	uint32_t p_len;
	char **p_values;

	//connection
	PGconn *conn;

	// results
	PGresult *result;
	int row_index;
	int column_index;

	//generatedkey
	int autoGeneratedKeys;
	struct agk_columns *columns;
};

static void postgres_pstmt_conversion(char *dest, const char *source)
{
	int i = 1;

	// FIXME what about literal '?' ... should it be converted?
	while (*source) {
		if ((*source) == '?') {
			*dest++ = '$';
			// FIXME calculate remaining room in dest and pass to sprintf
			int len = snprintf(dest, 12, "%d", i++);
			// FIXME check len against remaining room
			dest += len;
			source++;
		} else {
			*dest++ = *source++;
		}
	}

	*dest = '\0';
}

static void clear_statement(struct statement *stmt)
{
	if(stmt == NULL)
		return;

	free(stmt->command);
	stmt->command = NULL;

	if (stmt->type == PREPARED_STATEMENT) {
		unsigned int i;
		for (i = 0; i < stmt->p_len; i++) {
			free(stmt->p_values[i]);
			stmt->p_values[i] = NULL;
		}
		free(stmt->p_values);
		stmt->p_values = NULL;
	}

	if (stmt->result) {
		PQclear(stmt->result);
		stmt->result = NULL;
	}

	if (stmt->autoGeneratedKeys == RETURN_GENERATED_KEYS && stmt->columns) {
		unsigned int i;

		if (stmt->columns->names) {
			for (i = 0; i < stmt->columns->len; i++) {
				free(stmt->columns->names[i]);
				stmt->columns->names[i] = NULL;
			}
			free(stmt->columns->names);
			stmt->columns->names = NULL;
		} else {
			free(stmt->columns->indexes);
			stmt->columns->indexes = NULL;
		}

		free(stmt->columns);
		stmt->columns = NULL;
	}

	free(stmt);
	stmt = NULL;
}

static int execute_statement(duk_context *ctx, int argc, struct statement *stmt)
{
	char *error_message;

	if (stmt == NULL)
		return 0;

	/* If there is an old result clear the memory */
	if (stmt->result) {
		PQclear(stmt->result);
		stmt->result = NULL;
	}

	if (argc == 1 && stmt->type != SIMPLE_STATEMENT) {
		clear_statement(stmt);
		return 0;
	} else if (argc == 0 && stmt->type != PREPARED_STATEMENT) {
		clear_statement(stmt);
		return 0;
	}

	stmt->result = PQexecParams(stmt->conn,
			stmt->command,
			stmt->p_len,	/* parameters' length */
			NULL,		/* let the backend deduce param type */
			(const char **)stmt->p_values,
			NULL,		/* don't need param lengths since text */
			NULL,		/* default to all text params */
			TEXT_RESULT);	/* ask for text results */

	if (PQresultStatus(stmt->result) != PGRES_COMMAND_OK &&
			PQresultStatus(stmt->result) != PGRES_TUPLES_OK) {
		error_message = PQerrorMessage(stmt->conn);
		clear_statement(stmt);
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s", error_message);
	}

	return 1;
}

static int get_plen(const char *nativeSQL)
{
	int i, p_len;

	p_len = 0;

	for (i = 0; nativeSQL[i]; i++) {
		if (nativeSQL[i] == '?')
			p_len++;
	}

	return p_len;
}


static struct statement *generate_statement(duk_context *ctx, const char *nativeSQL, int autoGeneratedKeys)
{
	struct statement *stmt = malloc(sizeof(struct statement));

	if (stmt == NULL)
		return NULL;

	memset(stmt, 0, sizeof(struct statement));

	stmt->p_len = get_plen(nativeSQL);
	stmt->row_index = -1;
	stmt->column_index = 0;
	stmt->autoGeneratedKeys = autoGeneratedKeys;

	/* it supports maximum 99 parameters */
	if (stmt->p_len > MAX_PARAMETERS) {
		free(stmt);
		stmt = NULL;
		return NULL;
	}
	if (autoGeneratedKeys == RETURN_GENERATED_KEYS)
		stmt->command = malloc((strlen(nativeSQL) + stmt->p_len + stmt->p_len / 10 + 1 +
					POSTGRES_AUTOGENERATED_STRING_LENGTH) * sizeof(char));
	else
		stmt->command = malloc((strlen(nativeSQL) + stmt->p_len + stmt->p_len / 10 + 1) *
				sizeof(char));
	if (stmt->command == NULL) {
		free(stmt);
		stmt = NULL;
		return NULL;
	}

	if (stmt->p_len > 0) {
		stmt->type = PREPARED_STATEMENT;
		stmt->p_values = calloc(stmt->p_len, sizeof(char *));
		if (stmt->p_values == NULL) {
			free(stmt->command);
			stmt->command = NULL;
			free(stmt);
			stmt = NULL;
			return NULL;
		}
		postgres_pstmt_conversion(stmt->command, nativeSQL);
		if (autoGeneratedKeys == RETURN_GENERATED_KEYS)
			strncat(stmt->command, POSTGRES_AUTOGENERATED_STRING, POSTGRES_CONNECTOR_LEN);
	} else {
		stmt->type = SIMPLE_STATEMENT;
		strcpy(stmt->command, nativeSQL);
		if (autoGeneratedKeys == RETURN_GENERATED_KEYS)
			strncat(stmt->command, POSTGRES_AUTOGENERATED_STRING, POSTGRES_CONNECTOR_LEN);

		stmt->p_values = NULL;
	}

	return stmt;
}

/**
 * @brief Extract the array of auto generated keys from JS function parameter
 *
 * This is a helper function that examines the 2nd JS function parameter and
 * builds an array of either indices or column names that correspond to the
 * auto generated keys to be retrieved. The function is used to implement the
 * overloaded versions of the following functions:
 *   Connection.prepareStatement()
 *   Statement.execute()
 *   Statement.executeUpdate()
 */
static int get_columns_values(duk_context *ctx, struct agk_columns **columns)
{
	duk_size_t i, len;

	if (duk_is_null(ctx, 1))
		return 0;

	*columns = malloc (1 * sizeof(struct agk_columns));
	if (*columns == NULL)
		return 0;

	len = duk_get_length(ctx, 1);
	if (len == 0)
		return 0;

	(*columns)->len = len;

	duk_get_prop_index(ctx, 1, 0);

	if (duk_is_number(ctx, -1)) {
		duk_pop(ctx);
		(*columns)->indexes = malloc(len * sizeof(int));
		if ((*columns)->indexes == NULL)
			return 0;
		(*columns)->names = NULL;

		for (i = 0; i < len; i++) {
			duk_get_prop_index(ctx, 1, i);
			if (duk_is_undefined(ctx, -1)) {
				free((*columns)->indexes);
				(*columns)->indexes = NULL;
				return 0;
			}

			if (!duk_is_number(ctx, -1)) {
				free((*columns)->indexes);
				(*columns)->indexes = NULL;
				return 0;
			}

			(*columns)->indexes[i] = duk_get_number(ctx, -1);
			duk_pop(ctx);
		}
	} else if (duk_is_string(ctx, -1)) {
		duk_pop(ctx);
		(*columns)->names = malloc(len * sizeof(char *));
		if ((*columns)->names == NULL) {
			return 0;
		}
		(*columns)->indexes = NULL;

		for (i = 0; i < len; i++) {
			duk_get_prop_index(ctx, 1, i);
			if (duk_is_undefined(ctx, -1)) {
				free((*columns)->names);
				(*columns)->names = NULL;
				return 0;
			}

			if (!duk_is_string(ctx, -1)) {
				duk_size_t j;
				for (j = 0; j < i; j++) {
					free((*columns)->names[j]);
					(*columns)->names[j] = NULL;
				}
				free((*columns)->names);
				(*columns)->names = NULL;
				return 0;
			}

			const char *value = duk_get_string(ctx, -1);
			(*columns)->names[i] = malloc (strlen(value) * sizeof(char));
			if ((*columns)->names[i] == NULL) {
				duk_size_t j;
				for (j = 0; j < i; j++) {
					free((*columns)->names[j]);
					(*columns)->names[j] = NULL;
				}
				free((*columns)->names);
				(*columns)->names = NULL;
				return 0;
			}
			strcpy((*columns)->names[i], value);
			duk_pop(ctx);
		}
	} else
		return 0;

	return 1;
}

/**
 * @brief Retrieve one value from a result set
 *
 * This is the implementation of the following JS functions:
 *   ResultSet.getNumber()
 *   ResultSet.getString()
 *
 * The actual native C functions that correspond to the JS functions are just
 * thin wrappers around this function.
 */
static char *get_value_from_index(duk_context *ctx)
{
	struct statement *stmt;
	int column_index;
	const char *column_name;
	char *value;
	int argc = duk_get_top(ctx);

	duk_push_this(ctx);
	duk_get_prop_string(ctx, -1, "stmt");
	stmt = duk_get_pointer(ctx, -1);

	if (stmt == NULL)
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "The statement property is not set");

	if (argc != 1)
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "Wrong number of arguments");

	if (duk_is_number(ctx, 0)) {
		column_index = duk_get_int(ctx, 0);

		if (stmt->autoGeneratedKeys == RETURN_GENERATED_KEYS && stmt->columns != NULL) {
			if (column_index < 1 || column_index > stmt->columns->len)
				duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "Column index out of bounds");

			if (stmt->columns->indexes) {
					column_index = stmt->columns->indexes[column_index - 1];
			} else {
				column_index = PQfnumber(stmt->result, stmt->columns->names[column_index - 1]);
				if (column_index == -1)
					duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "The given name does not match any column.");
				/* Increment it because the column index is expected to start from 1 */
				column_index++;
			}
		}

		if (column_index < 1 || column_index > PQnfields(stmt->result)) {
			duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "Column index out of bounds");
		}
		column_index--;
	} else if (duk_is_string(ctx, 0)) {
		column_name = duk_get_string(ctx, 0);

		column_index = PQfnumber(stmt->result, column_name);
		if (column_index == -1)
			duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "The given name does not match any column.");
	} else {
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "[Wrong argument type]The first parameter should be a number \
				which represents the position of the parameter or a string (column label)");
	}

	if (stmt->row_index < 0 || stmt->row_index >= PQntuples(stmt->result))
			duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "Row index out of bounds");

	if (PQgetisnull(stmt->result, stmt->row_index, column_index)) {
		return NULL;
	}

	value = PQgetvalue(stmt->result, stmt->row_index, column_index);
	return value;
}

static void set_parameter(duk_context *ctx)
{
	int pos;
	const char *value;
	struct statement *stmt;
	int argc = duk_get_top(ctx);

	duk_push_this(ctx);
	duk_get_prop_string(ctx, -1, "stmt");
	stmt = duk_get_pointer(ctx, -1);

	if (stmt == NULL)
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "The statement property is not set");;

	if (argc < 1)
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "Wrong number of arguments");

	if (!duk_is_number(ctx, 0))
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "The first parameter should be a \
			number which represents the position of the parameter");

	pos = duk_get_int(ctx, 0);

	if (pos > stmt->p_len || pos < 1)
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "The position is incorrect!");

	pos--;

	if (stmt->p_values[pos] != NULL) {
		/* The element was already set */
		free(stmt->p_values[pos]);
		stmt->p_values[pos] = NULL;
	}

	/* If the parameter is NULL, let the value to remain NULL */
	if (argc < 2 || duk_is_null(ctx, 1)) {
		stmt->p_values[pos] = NULL;
	} else {
		value = duk_to_string(ctx, 1);
		stmt->p_values[pos] = malloc (strlen(value) * sizeof(char));
		if (stmt->p_values[pos] == NULL)
			duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s\n", "Failed to allocate memory");
		strcpy(stmt->p_values[pos], value);
	}
}

static int set_statement(duk_context *ctx, const char *query, int argc)
{
	const char *nativeSQL;
	int autoGeneratedKeys = NO_GENERATED_KEYS;
	struct agk_columns *columns = NULL;

	/* Call nativeSQL method on the connection object in the PreparedStatement given */
	duk_get_prop_string(ctx, -1, "connection");
	if (duk_is_undefined(ctx, -1)) {
		duk_pop(ctx);
		return 0;
	}

	duk_push_string(ctx, "nativeSQL");
	duk_push_string(ctx, query);
	duk_pcall_prop(ctx, -3, 1);
	nativeSQL = duk_get_string(ctx, -1);
	duk_pop(ctx);

	duk_get_prop_string(ctx, -1, "connection");
	PGconn *conn = (PGconn *)duk_get_pointer(ctx, -1);
	duk_pop(ctx);
	if (conn == NULL)
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s", "PGconn property is not set\n");

	if (argc == 2) {
		if (duk_get_number(ctx, 1) == 1  || duk_get_boolean(ctx, 1) == 1)
			autoGeneratedKeys = RETURN_GENERATED_KEYS;
		else if (duk_is_array(ctx, 1)) {
			if (get_columns_values(ctx, &columns) == 0)
				duk_error(ctx, DUK_ERR_TYPE_ERROR, "Failed to extract column names/indexes\n");
			else
				autoGeneratedKeys = RETURN_GENERATED_KEYS;
		}
	}

	struct statement *stmt = generate_statement(ctx, nativeSQL, autoGeneratedKeys);
	if (stmt == NULL)
		return 0;

	stmt->columns = columns;
	stmt->conn = conn;
	if (PQstatus(stmt->conn) != CONNECTION_OK) {
		clear_statement(stmt);
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "Wrong connection status %s\n", PQerrorMessage(stmt->conn));
	}

	/* Remove the connection object */
	duk_pop(ctx);

	/* Add property to the given Statement object */
	duk_push_pointer(ctx, (void *) stmt);
	duk_put_prop_string(ctx, -2, "stmt");

	return 1;
}

#if 0

#if 0
/**
 * pretty_printer - internal function used for debugging
 * @stmt: pointer to the structure
 */
static void pretty_printer(struct statement *stmt)
{
	unsigned int i;

	JS_Log(JS_LOG_INFO, "Statement type: %s | Parameters number %d\n",
			(stmt->type == SIMPLE_STATEMENT)? "SIMPLE_STATEMENT":"PREPARED_STATEMENT",
			stmt->p_len);
	JS_Log(JS_LOG_INFO, "Statement :\"%s\"\n", stmt->command);

	for (i = 0; i < stmt->p_len; i++) {
		JS_Log(JS_LOG_INFO, "%d argument: %s\n", i + 1,
				(stmt->p_values[i] == NULL)? "NULL":stmt->p_values[i]);
	}

	if (stmt->autoGeneratedKeys == RETURN_GENERATED_KEYS && stmt->columns) {
		if (stmt->columns->indexes) {
			for (i = 0; i < stmt->columns->len; i++) {
				JS_Log(JS_LOG_INFO, "Column index[%d] = %d\n", i, stmt->columns->indexes[i]);
			}
		} else {
			for (i = 0; i < stmt->columns->len; i++) {
				JS_Log(JS_LOG_INFO, "Column name[%d] = %s\n", i, stmt->columns->names[i]);
			}
		}
	}
}

/**
 * result_pretty_printer - internal function used for debugging
 * @stmt: pointer to the structure
 */
static void result_pretty_printer(struct statement *stmt)
{
	PQprint(stdout, stmt->result, NULL);
}
#endif

#endif

static int PgsqlResultSet_getNumber(duk_context *ctx)
{
	char *value = get_value_from_index(ctx);
	char *pEnd;
	double value_to_double;

	if (value == NULL) {
		duk_push_number(ctx, 0);
	}

	value_to_double = strtod(value, &pEnd);

	duk_push_number(ctx, value_to_double);
	return 1;
}

static int PgsqlResultSet_getString(duk_context *ctx)
{
	char *value = get_value_from_index(ctx);
	duk_push_string(ctx, value);
	return 1;
}

static int PgsqlResultSet_next(duk_context *ctx)
{
	struct statement *stmt;
	int argc = duk_get_top(ctx);

	duk_push_this(ctx);
	duk_get_prop_string(ctx, -1, "stmt");
	stmt = duk_get_pointer(ctx, -1);

	if (stmt == NULL) {
		duk_push_false(ctx);
		return 1;
	}

	if (argc != 0) {
		duk_push_false(ctx);
		return 1;
	}

	stmt->row_index += 1;

	if (stmt->row_index < 0 || stmt->row_index >= PQntuples(stmt->result)) {
		duk_push_false(ctx);
		return 1;
	}

	duk_push_true(ctx);
	return 1;
}

static int PgsqlResultSet_first(duk_context *ctx)
{
	struct statement *stmt;
	int argc = duk_get_top(ctx);

	duk_push_this(ctx);
	duk_get_prop_string(ctx, -1, "stmt");
	stmt = duk_get_pointer(ctx, -1);

	if (stmt == NULL) {
		duk_push_false(ctx);
		return 1;
	}

	if (argc != 0) {
		duk_push_false(ctx);
		return 1;
	}

	stmt->row_index = 0;

	duk_push_true(ctx);
	return 1;
}

static int PgsqlResultSet_last(duk_context *ctx)
{
	struct statement *stmt;
	int argc = duk_get_top(ctx);

	duk_push_this(ctx);
	duk_get_prop_string(ctx, -1, "stmt");
	stmt = duk_get_pointer(ctx, -1);

	if (stmt == NULL) {
		duk_push_false(ctx);
		return 1;
	}

	if (argc != 0) {
		duk_push_false(ctx);
		return 1;
	}

	stmt->row_index = PQntuples(stmt->result) - 1;

	duk_push_true(ctx);
	return 1;
}

static int PgsqlResultSet_finalize(duk_context *ctx)
{
	struct statement *stmt;
	duk_get_prop_string(ctx, 0, "stmt");
	if (!duk_is_undefined(ctx, -1)) {
		stmt = duk_get_pointer(ctx, -1);

		if (stmt && stmt->result) {
			PQclear(stmt->result);
			stmt->result = NULL;
		}
	}

	printf("in finalize la result set: ");
	return 0;
}

static duk_function_list_entry PgsqlResultSet_functions[] = {
	{"getNumber",	PgsqlResultSet_getNumber,	1},
	{"getString",	PgsqlResultSet_getString,	1},
	{"next",	PgsqlResultSet_next,		0},
	{"first",	PgsqlResultSet_first,		0},
	{"last",	PgsqlResultSet_last,		0},
	{NULL,		NULL, 				0}
};

static int PgsqlStatement_execute(duk_context *ctx)
{
	struct statement *stmt;
	int argc = duk_get_top(ctx);

	if (argc < 0 || argc > 2)
			duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s", "Wrong number of arguments\n");

	if (argc > 0) {
		/* if there is an old statement clear the memory */
		duk_push_this(ctx);
		duk_get_prop_string(ctx, -1, "stmt");
		stmt = duk_get_pointer(ctx, -1);
		if (stmt)
			clear_statement(stmt);

		duk_push_this(ctx);
		if (!set_statement(ctx, duk_get_string(ctx, 0), argc)) {
			/* TODO error */
			return DUK_RET_ERROR;
		}
	}

	duk_push_this(ctx);
	duk_get_prop_string(ctx, -1, "stmt");
	stmt = duk_get_pointer(ctx, -1);
	if (stmt == NULL)
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s", "The statement property is not set\n");

	if (execute_statement(ctx, argc, stmt))
		duk_push_true(ctx);
	else
		duk_push_false(ctx);

	return 1;
}

static int PgsqlStatement_executeQuery(duk_context *ctx)
{
	int argc = duk_get_top(ctx);
	struct statement *stmt;

	/* if it is a simple statement set the SQL command*/
	if (argc == 1) {
		duk_push_this(ctx);
		duk_get_prop_string(ctx, -1, "stmt");
		stmt = duk_get_pointer(ctx, -1);
		if (stmt)
			clear_statement(stmt);

		duk_push_this(ctx);
		if (!set_statement(ctx, duk_get_string(ctx, 0), argc)) {
			/* TODO error */
			return DUK_RET_ERROR;
		}
	}

	duk_push_this(ctx);
	duk_get_prop_string(ctx, -1, "stmt");
	stmt = duk_get_pointer(ctx, -1);
	if (stmt == NULL) {
		duk_push_null(ctx);
		return 1;
	}

	if (!execute_statement(ctx, argc, stmt)) {
		if(stmt)
			clear_statement(stmt);
		duk_push_null(ctx);
		return 1;
	}

	/* Create PostgreSQL Result Set object */
	duk_push_object(ctx);

	duk_get_global_string(ctx, "PgsqlResultSet");
	duk_set_prototype(ctx, -2);

	duk_push_pointer(ctx, (void *) stmt);
	duk_put_prop_string(ctx, -2, "stmt");

	return 1;
}

static int PgsqlStatement_executeUpdate(duk_context *ctx)
{
	int argc = duk_get_top(ctx);
	struct statement *stmt;

	if (argc < 0 || argc > 2)
		return DUK_RET_ERROR;

	if (argc > 0) {
		duk_push_this(ctx);
		duk_get_prop_string(ctx, -1, "stmt");
		stmt = duk_get_pointer(ctx, -1);
		if (stmt)
			clear_statement(stmt);

		duk_push_this(ctx);
		if (!set_statement(ctx, duk_get_string(ctx, 0), argc)) {
			/* TODO error */
			return DUK_RET_ERROR;
		}
	}

	duk_push_this(ctx);
	duk_get_prop_string(ctx, -1, "stmt");
	stmt = duk_get_pointer(ctx, -1);
	if (stmt == NULL) {
		duk_push_number(ctx, -1);
		return 1;
	}

	if (!execute_statement(ctx, argc, stmt)) {
		if(stmt)
			clear_statement(stmt);
		duk_push_number(ctx, -1);
		return 1;
	}

	duk_push_number(ctx, atoi(PQcmdTuples(stmt->result)));
	return 1;
}

static int PgsqlStatement_getConnection(duk_context *ctx)
{
	duk_push_this(ctx);

	duk_get_prop_string(ctx, -1, "connection");

	return 1;
}

static int PgsqlStatement_getGeneratedKeys(duk_context *ctx)
{
	struct statement *stmt;

	duk_push_this(ctx);
	duk_get_prop_string(ctx, -1, "stmt");
	stmt = duk_get_pointer(ctx, -1);

	if (stmt == NULL) {
		duk_push_null(ctx);
		return 1;
	}

	if (stmt->autoGeneratedKeys != RETURN_GENERATED_KEYS) {
		duk_push_null(ctx);
		return 1;
	}

	duk_push_object(ctx);

	duk_get_global_string(ctx, "PgsqlResultSet");
	duk_set_prototype(ctx, -2);

	duk_push_pointer(ctx, (void *) stmt);
	duk_put_prop_string(ctx, -2, "stmt");

	return 1;
}

static int PgsqlStatement_getResultSet(duk_context *ctx)
{
	struct statement *stmt;

	duk_push_this(ctx);
	duk_get_prop_string(ctx, -1, "stmt");
	stmt = duk_get_pointer(ctx, -1);

	if (stmt == NULL) {
		duk_push_null(ctx);
		return 1;
	}

	duk_push_object(ctx);

	duk_get_global_string(ctx, "PgsqlResultSet");
	duk_set_prototype(ctx, -2);

	duk_push_pointer(ctx, (void *) stmt);
	duk_put_prop_string(ctx, -2, "stmt");

	return 1;
}

static int PgsqlStatement_getUpdateCount(duk_context *ctx)
{
	struct statement *stmt;

	duk_push_this(ctx);
	duk_get_prop_string(ctx, -1, "stmt");
	stmt = duk_get_pointer(ctx, -1);

	if (stmt == NULL || stmt->result == NULL) {
		duk_push_number(ctx, -1);
		return 1;
	}

	duk_push_number(ctx, atoi(PQcmdTuples(stmt->result)));
	return 1;
}

static int PgsqlStatement_finalize(duk_context *ctx)
{
	struct statement *stmt;
	duk_get_prop_string(ctx, 0, "stmt");
	if (!duk_is_undefined(ctx, -1)) {
		stmt = duk_get_pointer(ctx, -1);

		if (stmt != NULL)
			clear_statement(stmt);
	}

	printf("in finalize la statement: ");
	return 0;
}

static duk_function_list_entry PgsqlStatement_functions[] = {
	{"execute",		PgsqlStatement_execute,			DUK_VARARGS},
	{"executeQuery",	PgsqlStatement_executeQuery,		DUK_VARARGS},
	{"executeUpdate",	PgsqlStatement_executeUpdate,		DUK_VARARGS},
	{"getConnection",	PgsqlStatement_getConnection,		0},
	{"getGeneratedKeys",	PgsqlStatement_getGeneratedKeys,	0},
	{"getResultSet",	PgsqlStatement_getResultSet,		0},
	{"getUpdateCount",	PgsqlStatement_getUpdateCount,		0},
	{NULL,			NULL, 					0}
};

static int PgsqlPreparedStatement_setNumber(duk_context *ctx)
{
	if (!duk_is_number(ctx, 1) || duk_is_null(ctx, 1))
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s", "The value is not a number!\n");

	set_parameter(ctx);

	return 0;
}

static int PgsqlPreparedStatement_setString(duk_context *ctx)
{
	if (!duk_is_string(ctx, 1) || duk_is_null(ctx, 1))
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s", "The value is not a string!\n");

	set_parameter(ctx);

	return 0;
}

static duk_function_list_entry PgsqlPreparedStatement_functions[] = {
	{"setNumber",		PgsqlPreparedStatement_setNumber,			2},
	{"setString",	PgsqlPreparedStatement_setString,		2},
	{NULL,			NULL, 						0}
};

static int PgsqlConnection_createStatement(duk_context *ctx)
{
	/* Create PostgreSQL Statement object */
	duk_push_object(ctx);

	duk_get_global_string(ctx, "PgsqlStatement");
	duk_set_prototype(ctx, -2);

	/* Add connection property */
	duk_push_this(ctx);
	duk_put_prop_string(ctx, -2, "connection");

	return 1;
}

static int PgsqlConnection_prepareStatement(duk_context *ctx)
{
	int argc = duk_get_top(ctx);

	if (argc < 1 || argc > 2)
		return DUK_RET_ERROR;

	/* Create MySQL Prepared Statement object */
	duk_push_object(ctx);

	duk_get_global_string(ctx, "PgsqlPreparedStatement");
	duk_set_prototype(ctx, -2);

	/* Add connection property */
	duk_push_this(ctx);
	duk_put_prop_string(ctx, -2, "connection");


	/* set_statement uses the duktape stack for the PreparedStatement object
	and receives also the query and the number of arguments as a normal param.
	It will simply add the statement struct as a property to the Statement object. */
	if (!set_statement(ctx, duk_get_string(ctx, 0), argc)) {
		/* TODO error */
		return DUK_RET_ERROR;
	}

	return 1;
}

static int PgsqlConnection_nativeSQL(duk_context *ctx)
{
	int argc = duk_get_top(ctx);

	if (argc != 1)
		return DUK_RET_ERROR;

	duk_to_string(ctx, 0);

	/* duk_to_string also replaces the value at idx with ToString(val) */
	duk_dup(ctx, 0);

	return 1;
}

static int PgsqlConnection_finalize(duk_context *ctx)
{
	PGconn *conn;
	duk_get_prop_string(ctx, 0, "connection");
	conn = duk_get_pointer(ctx, -1);

	if (conn != NULL)
		PQfinish(conn);

	printf("in finalize la connection: ");
	return 0;
}

static duk_function_list_entry PgsqlConnection_functions[] = {
	{"createStatement",	PgsqlConnection_createStatement,	1},
	{"prepareStatement",	PgsqlConnection_prepareStatement,	2},
	{"nativeSQL",		PgsqlConnection_nativeSQL,		1},
	{NULL,			NULL,					0}
};

static int PgsqlDriver_connect(duk_context *ctx)
{
	int argc = duk_get_top(ctx);
	int sep_pos, db_sep;
	const char *url;
	char *host, *cursor, *port_str;
	char postgres_connector[POSTGRES_CONNECTOR_LEN];
	unsigned int port;
	const char *user = NULL;
	const char *password = NULL;

	if (!argc)
		return DUK_RET_ERROR;

	url = duk_safe_to_string(ctx, 0);

	if (url == NULL) {
		duk_push_null(ctx);
		return 1;
	}

	if (strncmp(url, POSTGRES_URI, POSTGRES_URI_LEN)) {
		duk_push_null(ctx);
		return 1;
	}

	host = strdup(url + POSTGRES_URI_LEN);
	port = POSTGRES_DEFAULT_PORT;

	sep_pos = strcspn(host, ":/");
	if (sep_pos == strlen(host)) {
		free(host);
		duk_push_null(ctx);
		return 1;
	}

	cursor = host + sep_pos;
	if (*cursor == ':') {
		*(cursor++) = '\0';
		port_str = cursor;
		db_sep = strcspn(cursor, "/");

		if (db_sep == strlen(cursor)) {
			free(host);
			duk_push_null(ctx);
			return 1;
		}

		cursor += db_sep;
		*(cursor++) = '\0';
		port = atoi(port_str);
	} else if (*cursor == '/') {
		*(cursor++) = '\0';
	} else {
		free(host);
		duk_push_null(ctx);
		return 1;
	}

	sprintf(postgres_connector, "dbname=%s hostaddr=%s port=%d",
			cursor, host, port);

	if (argc > 1 && duk_is_object(ctx, 1)) {

		duk_get_prop_string(ctx, 1, "user");

		if (!duk_is_undefined(ctx, -1)) {
			user = duk_safe_to_string(ctx, -1);
			strcat(postgres_connector, " user=");
			strcat(postgres_connector, user);
		}

		duk_get_prop_string(ctx, 1, "password");

		if (!duk_is_undefined(ctx, -1)) {
			password = duk_safe_to_string(ctx, -1);
			strcat(postgres_connector, " password=");
			strcat(postgres_connector, password);
		}
	}

	PGconn *connection;
	connection = PQconnectdb(postgres_connector);
	if (PQstatus(connection) != CONNECTION_OK) {
		PQfinish(connection);
		duk_error(ctx, DUK_ERR_TYPE_ERROR, "%s", PQerrorMessage(connection));
	}

	/* Create Connection object */
	duk_push_object(ctx);

	duk_get_global_string(ctx, "PgsqlConnection");
	duk_set_prototype(ctx, -2);

	duk_push_pointer(ctx, (void *) connection);
	duk_put_prop_string(ctx, -2, "connection");

	return 1;
}

static int PgsqlDriver_acceptsURL(duk_context *ctx)
{
	const char *url = duk_safe_to_string(ctx, 0);

	if (strncmp(url, POSTGRES_URI, POSTGRES_URI_LEN))
		duk_push_false(ctx);
	else
		duk_push_true(ctx);

	return 1;
}

static duk_function_list_entry PgsqlDriver_functions[] = {
	{"acceptsURL",	PgsqlDriver_acceptsURL,	1},
	{"connect",	PgsqlDriver_connect,	2},
	{NULL,		NULL,			0}
};

duk_bool_t js_pgsql_construct_and_register(duk_context *ctx)
{
	int rc;

	/* Create PostgreSQL Connection "class" */
	duk_push_object(ctx);
	duk_put_function_list(ctx, -1, PgsqlConnection_functions);
	duk_push_c_function(ctx, PgsqlConnection_finalize, 2);
	duk_set_finalizer(ctx, -2);
	duk_put_global_string(ctx, "PgsqlConnection");

	/* Create PostgreSQL ResultSet "class" */
	duk_push_object(ctx);
	duk_put_function_list(ctx, -1, PgsqlResultSet_functions);
	duk_push_c_function(ctx, PgsqlResultSet_finalize, 2);
	duk_set_finalizer(ctx, -2);
	duk_put_global_string(ctx, "PgsqlResultSet");

	/* Create PostgreSQL Statement "class" */
	duk_push_object(ctx);

	duk_get_global_string(ctx, "Statement");
	duk_set_prototype(ctx, -2);

	duk_put_function_list(ctx, -1, PgsqlStatement_functions);
	duk_push_c_function(ctx, PgsqlStatement_finalize, 2);
	duk_set_finalizer(ctx, -2);
	duk_put_global_string(ctx, "PgsqlStatement");

	/* Create PostgreSQL PreparedStatement "class" */
	duk_push_object(ctx);

	duk_get_global_string(ctx, "PgsqlStatement");
	duk_set_prototype(ctx, -2);

	duk_put_function_list(ctx, -1, PgsqlPreparedStatement_functions);
	duk_put_global_string(ctx, "PgsqlPreparedStatement");

	/* Create PostgreSQL Driver object */
	duk_push_object(ctx);
	duk_put_function_list(ctx, -1, PgsqlDriver_functions);
	duk_put_global_string(ctx, "PgsqlDriver");

	/* Register driver to DriverManager */
	duk_get_global_string(ctx, "DriverManager");
	duk_push_string(ctx, "registerDriver");
	duk_get_global_string(ctx, "PgsqlDriver");
	rc = duk_pcall_prop(ctx, -3, 1);

	return !rc;
}
