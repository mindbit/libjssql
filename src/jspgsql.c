/* SPDX-License-Identifier: MIT */

#define _GNU_SOURCE
#include <jsmisc.h>
#include <libpq-fe.h>

#include "jspgsql.h"
#include "jssql.h"
#include "jscommon.h"

struct agk_columns {
	uint32_t len;
	int *indexes;
	char **names;
};

struct statement {
	char *command;
	int type;	//this can be removed because we can identify the type
			//of statement using p_len

	// parameters
	uint32_t p_len;
	char **p_values;

	//connection
	PGconn *conn;

	// results
	PGresult *result;
	uint32_t row_index;
	uint32_t column_index;

	//generatedkey
	int autoGeneratedKeys;
	struct agk_columns *columns;
};

#if 0

#if 0
/**
 * pretty_printer - internal function used for debugging
 * @stmt: pointer to the structure
 */
static void pretty_printer(struct statement *stmt)
{
	unsigned int i;

	JS_Log(JS_LOG_INFO, "Statement type: %s | Parameters number %d\n",
			(stmt->type == SIMPLE_STATEMENT)? "SIMPLE_STATEMENT":"PREPARED_STATEMENT",
			stmt->p_len);
	JS_Log(JS_LOG_INFO, "Statement :\"%s\"\n", stmt->command);

	for (i = 0; i < stmt->p_len; i++) {
		JS_Log(JS_LOG_INFO, "%d argument: %s\n", i + 1,
				(stmt->p_values[i] == NULL)? "NULL":stmt->p_values[i]);
	}

	if (stmt->autoGeneratedKeys == RETURN_GENERATED_KEYS && stmt->columns) {
		if (stmt->columns->indexes) {
			for (i = 0; i < stmt->columns->len; i++) {
				JS_Log(JS_LOG_INFO, "Column index[%d] = %d\n", i, stmt->columns->indexes[i]);
			}
		} else {
			for (i = 0; i < stmt->columns->len; i++) {
				JS_Log(JS_LOG_INFO, "Column name[%d] = %s\n", i, stmt->columns->names[i]);
			}
		}
	}
}

/**
 * result_pretty_printer - internal function used for debugging
 * @stmt: pointer to the structure
 */
static void result_pretty_printer(struct statement *stmt)
{
	PQprint(stdout, stmt->result, NULL);
}
#endif

/**
 * clear_statement - clears the statement structure
 * @stmt: pointer to the structure
 */
static void clear_statement(struct statement *stmt)
{
	if(stmt == NULL)
		return;

	free(stmt->command);
	stmt->command = NULL;

	if (stmt->type == PREPARED_STATEMENT) {
		unsigned int i;
		for (i = 0; i < stmt->p_len; i++) {
			free(stmt->p_values[i]);
			stmt->p_values[i] = NULL;
		}
		free(stmt->p_values);
		stmt->p_values = NULL;
	}

	if (stmt->result) {
		PQclear(stmt->result);
		stmt->result = NULL;
	}

	if (stmt->autoGeneratedKeys == RETURN_GENERATED_KEYS && stmt->columns) {
		unsigned int i;

		if (stmt->columns->names) {
			for (i = 0; i < stmt->columns->len; i++) {
				free(stmt->columns->names[i]);
				stmt->columns->names[i] = NULL;
			}
			free(stmt->columns->names);
			stmt->columns->names = NULL;
		} else {
			free(stmt->columns->indexes);
			stmt->columns->indexes = NULL;
		}

		free(stmt->columns);
		stmt->columns = NULL;
	}

	free(stmt);
	stmt = NULL;
}

/**
 * get_plen - counts the parameters' number
 * @nativeSQL: SQL command
 */
static int get_plen(char *nativeSQL)
{
	int i, p_len;

	p_len = 0;

	for (i = 0; nativeSQL[i]; i++) {
		if (nativeSQL[i] == '?')
			p_len++;
	}

	return p_len;
}

/**
 * postgres_pstmt_conversion - converts a prepared statement to a
 * postgresql's one
 * @dest: the result
 * @source: SQL command which will be converted
 */
static void postgres_pstmt_conversion(char *dest, char *source)
{
	int i = 1;

	// FIXME what about literal '?' ... should it be converted?
	while (*source) {
		if ((*source) == '?') {
			*dest++ = '$';
			// FIXME calculate remaining room in dest and pass to sprintf
			int len = snprintf(dest, 12, "%d", i++);
			// FIXME check len against remaining room
			dest += len;
			source++;
		} else {
			*dest++ = *source++;
		}
	}

	*dest = '\0';
}

/**
 * generate_statement - creates a new statement using the SQL command
 * @cx: the JavaScript context
 * @cmd: SQL command
 * @autoGeneratedKeys: specifies if it should return the autogenerated values
 *
 * Returns a pointer to the statement structure or NULL in case of failure.
 */
static struct statement *generate_statement(JSContext *cx, jsval cmd, int autoGeneratedKeys)
{
	struct statement *stmt = malloc(sizeof(struct statement));

	if (stmt == NULL) {
		JS_Log(JS_LOG_ERR, "Failed to allocate memory for statement structure\n");
		return NULL;
	}
	memset(stmt, 0, sizeof(struct statement));

	char *nativeSQL = JS_EncodeStringValue(cx, cmd);

	stmt->p_len = get_plen(nativeSQL);
	stmt->row_index = -1;
	stmt->column_index = 0;
	stmt->autoGeneratedKeys = autoGeneratedKeys;

	/* it supports maximum 99 parameters */
	if (stmt->p_len > MAX_PARAMETERS) {
		free(stmt);
		stmt = NULL;
		free(nativeSQL);
		nativeSQL = NULL;
		return NULL;
	}
	if (autoGeneratedKeys == RETURN_GENERATED_KEYS)
		stmt->command = malloc((strlen(nativeSQL) + stmt->p_len + stmt->p_len / 10 + 1 +
					POSTGRES_AUTOGENERATED_STRING_LENGTH) * sizeof(char));
	else
		stmt->command = malloc((strlen(nativeSQL) + stmt->p_len + stmt->p_len / 10 + 1) *
				sizeof(char));
	if (stmt->command == NULL) {
		free(stmt);
		stmt = NULL;
		free(nativeSQL);
		nativeSQL = NULL;
		JS_Log(JS_LOG_ERR, "Failed to allocate memory for statement command\n");
		return NULL;
	}

	if (stmt->p_len > 0) {
		stmt->type = PREPARED_STATEMENT;
		stmt->p_values = calloc(stmt->p_len, sizeof(char *));
		if (stmt->p_values == NULL) {
			free(stmt->command);
			stmt->command = NULL;
			free(stmt);
			stmt = NULL;
			free(nativeSQL);
			nativeSQL = NULL;
			JS_Log(JS_LOG_ERR, "Failed to allocate memory for statement values\n");
			return NULL;
		}
		postgres_pstmt_conversion(stmt->command, nativeSQL);
		if (autoGeneratedKeys == RETURN_GENERATED_KEYS)
			strncat(stmt->command, POSTGRES_AUTOGENERATED_STRING, POSTGRES_CONNECTOR_LEN);
	} else {
		stmt->type = SIMPLE_STATEMENT;
		strcpy(stmt->command, nativeSQL);
		if (autoGeneratedKeys == RETURN_GENERATED_KEYS)
			strncat(stmt->command, POSTGRES_AUTOGENERATED_STRING, POSTGRES_CONNECTOR_LEN);

		stmt->p_values = NULL;
	}
	free(nativeSQL);
	return stmt;
}

/**
 * PgsqlResultSet_get - Retrieves the value of the designated column in the
 * current row of this ResultSet object as a String. (this is an internal function)
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns the number on success and JS_NULL on failure
 */
static inline JSBool
PgsqlResultSet_get(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval this = JS_THIS(cx, vp);
	struct statement *stmt = (struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));
	JSBool ret = JS_TRUE;
	jsval rval = JSVAL_NULL;
	int column_index;

	if (stmt == NULL) {
		JS_Log(JS_LOG_ERR, "The statement property is not set\n");
		ret = JS_FALSE;
		goto out;
	}

	if (argc != 1) {
		JS_Log(JS_LOG_WARNING, "Wrong number of arguments\n");
		ret = JS_FALSE;
		goto out;
	}

	if (JSVAL_IS_INT(JS_ARGV(cx, vp)[0])) {
		column_index = JSVAL_TO_INT(JS_ARGV(cx, vp)[0]);

		if (stmt->autoGeneratedKeys == RETURN_GENERATED_KEYS && stmt->columns != NULL) {
			if (column_index < 1 || column_index > stmt->columns->len) {
				JS_Log(JS_LOG_WARNING, "Column index out of bounds\n");
				ret = JS_FALSE;
				goto out;
			}

			if (stmt->columns->indexes) {
				column_index = stmt->columns->indexes[column_index - 1];
			} else {
				column_index = PQfnumber(stmt->result, stmt->columns->names[column_index - 1]);
				if (column_index == -1) {
					ret = JS_FALSE;
					JS_Log(JS_LOG_WARNING, "The given name does not match any column.");
					goto out;
				}
				column_index++; //increment it because the column index is expected to start from 1
			}
		}

		if (column_index < 1 || column_index > PQnfields(stmt->result)) {
			JS_Log(JS_LOG_WARNING, "Column index out of bounds\n");
			ret = JS_FALSE;
			goto out;
		}
		column_index--;

		if (stmt->row_index < 0 || stmt->row_index >= PQntuples(stmt->result)) {
			JS_Log(JS_LOG_WARNING, "Row index out of bounds\n");
			ret = JS_FALSE;
			goto out;
		}
	} else if (JSVAL_IS_STRING(JS_ARGV(cx, vp)[0])) {
		char *column_name = JS_EncodeStringValue(cx, JS_ARGV(cx, vp)[0]);
		if (column_name == NULL) {
			ret = JS_FALSE;
			goto out;
		}

		column_index = PQfnumber(stmt->result, column_name);
		if (column_index == -1) {
			ret = JS_FALSE;
			free(column_name);
			JS_Log(JS_LOG_WARNING, "The given name does not match any column.");
			goto out;
		}
		free(column_name);
	} else {
		JS_Log(JS_LOG_WARNING, "[Wrong argument type]The first parameter should be a number \
				which represents the position of the parameter or a string (column label)\n");
		ret = JS_FALSE;
		goto out;
	}

	if (PQgetisnull(stmt->result, stmt->row_index, column_index)) {
		ret = JS_FALSE;
		//FIXME not sure if I should return a NULL/empty string
		goto out;
	}

	char *value = PQgetvalue(stmt->result, stmt->row_index, column_index);
	char *pEnd;
	long value_to_double = strtol(value, &pEnd, 10);

	//check if the value is a number
	if (pEnd == '\0' || pEnd != value) {
		rval = JS_NumberValue(value_to_double);
	} else {
		JSString *str = JS_NewStringCopyN(cx, value, strlen(value));
		if (str)
			rval = STRING_TO_JSVAL(str);
	}

out:
	JS_SET_RVAL(cx, vp, rval);
	return ret;
}

/**
 * PgsqlResultSet_getNumber - Retrieves the value of the designated column in the
 * current row of this ResultSet object as a number.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns the number on success and JS_NULL on failure
 */
static JSBool PgsqlResultSet_getNumber(JSContext *cx, unsigned argc, jsval *vp)
{
	if (!PgsqlResultSet_get(cx, argc, vp))
		return JS_TRUE;

	if (!JSVAL_IS_NUMBER(*vp)) {
		JS_Log(JS_LOG_WARNING, "The result value from that position is not a number\n");
		JS_SET_RVAL(cx, vp, JSVAL_NULL);
	}

	return JS_TRUE;
}

/**
 * PgsqlResultSet_getString - Retrieves the value of the designated column in the
 * current row of this ResultSet object as a String.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns the string on success and JS__NULL on failure
 */
static JSBool PgsqlResultSet_getString(JSContext *cx, unsigned argc, jsval *vp)
{
	PgsqlResultSet_get(cx, argc, vp);

	return JS_TRUE;
}

/**
 * PgsqlResultSet_next - Moves the cursor froward one row from its current position.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns JS_TRUE on success and JS_FALSE on failure
 */
static JSBool PgsqlResultSet_next(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval this = JS_THIS(cx, vp);
	struct statement *stmt = (struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));
	jsval rval = JSVAL_TRUE;

	if (stmt == NULL) {
		JS_Log(JS_LOG_ERR, "The statement property is not set\n");
		rval = JSVAL_FALSE;
		goto out;
	}

	if (argc != 0) {
		JS_Log(JS_LOG_WARNING, "Wrong number of arguments\n");
		rval = JSVAL_FALSE;
		goto out;
	}

	stmt->row_index += 1;

	if (stmt->row_index < 0 || stmt->row_index > PQntuples(stmt->result) - 1) {
		JS_Log(JS_LOG_INFO, "Row index out of bounds\n");
		rval = JSVAL_FALSE;
		goto out;
	}

out:
	JS_SET_RVAL(cx, vp, rval);
	return JS_TRUE;
}

/**
 * PgsqlResultSet_first - Moves the cursor to the first row in this ResultSet object.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns JS_TRUE on success and JS_FALSE on failure
 */
static JSBool PgsqlResultSet_first(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval this = JS_THIS(cx, vp);
	struct statement *stmt = (struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));
	jsval rval = JSVAL_TRUE;

	if (stmt == NULL) {
		JS_Log(JS_LOG_ERR, "The statement property is not set\n");
		rval = JSVAL_FALSE;
		goto out;
	}

	if (argc != 0) {
		JS_Log(JS_LOG_WARNING, "Wrong number of arguments\n");
		rval = JSVAL_FALSE;
		goto out;
	}

	stmt->row_index = 0;

out:
	JS_SET_RVAL(cx, vp, rval);
	return JS_TRUE;
}

/**
 * PgsqlResultSet_last - Moves the cursor to the last row in this ResultSet object.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns JS_TRUE on success and JS_FALSE on failure
 */
static JSBool PgsqlResultSet_last(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval this = JS_THIS(cx, vp);
	struct statement *stmt = (struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));
	jsval rval = JSVAL_TRUE;

	if (stmt == NULL) {
		JS_Log(JS_LOG_ERR, "The statement property is not set\n");
		rval = JSVAL_FALSE;
		goto out;
	}

	if (argc != 0) {
		JS_Log(JS_LOG_WARNING, "Wrong number of arguments\n");
		rval = JSVAL_FALSE;
		goto out;
	}

	stmt->row_index = PQntuples(stmt->result) - 1;

out:
	JS_SET_RVAL(cx, vp, rval);
	return JS_TRUE;
}

/**
 * PgsqlResultSet_finalize - cleanup function for ResultSet objects
 * @cx: JavaScript context
 * @obj: object
 */
static void PgsqlResultSet_finalize(JSFreeOp *fop, JSObject *obj)
{
	struct statement *stmt = (struct statement *)JS_GetPrivate(obj);

	if (stmt && stmt->result) {
		PQclear(stmt->result);
		stmt->result = NULL;
	}
}

static JSClass PgsqlResultSet_class = {
	"PgsqlResultSet",		//name of the class
	JSCLASS_HAS_PRIVATE,		//flags
	JS_PropertyStub,		//addProperty (default value JS_PropertyStrub)
	JS_PropertyStub,		//delProperty (default)
	JS_PropertyStub,		//getProperty (default)
	JS_StrictPropertyStub,		//setProperty (default value JS_StrictPropertyStub)
	JS_EnumerateStub,		//enumerate (default)
	JS_ResolveStub,			//resolve -lazy properties(default)
	JS_ConvertStub,			//conversion to primitive value (default)
	PgsqlResultSet_finalize,	//cleanup
};

static JSFunctionSpec PgsqlResultSet_functions[] = {
	JS_FS("getNumber", PgsqlResultSet_getNumber, 1, 0),
	JS_FS("getString", PgsqlResultSet_getString, 1, 0),
	JS_FS("next", PgsqlResultSet_next, 0, 0),
	JS_FS("first", PgsqlResultSet_first, 0, 0),
	JS_FS("last", PgsqlResultSet_last, 0, 0),
	JS_FS_END
};

/**
 * statement_get_result_set - Creates a ResultSet object
 * @cx: the JavaScript context
 * @stmt: pointer tot the structure which contains the result
 * @vp: return value
 *
 * Returns JS_TRUE on success and JS_FALSE on failure
 */
static JSBool
statement_get_result_set(JSContext *cx, struct statement *stmt, jsval *vp)
{
	JSBool ret = JS_TRUE;
	jsval rval = JSVAL_NULL;

	JSObject *obj = JS_NewObject(cx, &PgsqlResultSet_class, NULL, NULL);
	if (obj == NULL) {
		ret = JS_FALSE;
		JS_ReportError(cx, "Failed to create a new object\n");
		JS_Log(JS_LOG_ERR, "Failed to create a new object\n");
		goto out;
	}

	JS_SetPrivate(obj, stmt);

	if (JS_DefineFunctions(cx, obj, PgsqlResultSet_functions) == JS_FALSE) {
		ret = JS_FALSE;
		JS_ReportError(cx, "Failed to define functions for PgsqlResultSet\n");
		JS_Log(JS_LOG_ERR, "Failed to define functions for PgsqlResultSet\n");
		goto out;
	}

	rval = OBJECT_TO_JSVAL(obj);

out:
	JS_SET_RVAL(cx, vp, rval);
	return ret;
}

/**
 * get_columns_values - internal function used to get columns' indexes/names
 * @cx: the JavaScript context
 * @vp: return value
 * @stmt: pointer to the structure
 *
 * Returns JS_TRUE on success and JS_FALSE on failure
 */
static JSBool
get_columns_values(JSContext *cx, jsval *vp, struct agk_columns **columns)
{
	if (JSVAL_IS_NULL(JS_ARGV(cx, vp)[1])) {
		JS_Log(JS_LOG_INFO, "The array is NULL\n");
		goto out;
	}

	*columns = malloc (1 * sizeof(struct agk_columns));
	if (*columns == NULL) {
		JS_Log(JS_LOG_ERR, "Failed to allocate memory\n");
		goto out;
	}

	uint32_t len;
	JSObject *param = JSVAL_TO_OBJECT(JS_ARGV(cx, vp)[1]);

	if (!JS_GetArrayLength(cx, param, &len)) {
		JS_Log(JS_LOG_ERR, "Failed to get array length\n");
		goto out_clean;
	}

	if (len == 0) {	//FIXME not sure if needed (maybe JSVAL_IS_NULL already checked this)
		JS_Log(JS_LOG_INFO, "The array is empty\n");
		goto out_clean;
	}

	(*columns)->len = len;
	jsval elem_it;
	unsigned int i;

	if (!JS_GetElement(cx, param, 0, &elem_it)) {
		JS_Log(JS_LOG_ERR, "Failed to get the first element from array\n");
		goto out_clean;
	}

	if (JSVAL_IS_INT(elem_it)) {
		(*columns)->indexes = malloc(len * sizeof(int));
		if ((*columns)->indexes == NULL) {
			JS_Log(JS_LOG_ERR, "Failed to allocate memory\n");
			goto out;
		}
		(*columns)->names = NULL;

		for (i = 0; i < len; i++) {
			if (!JS_GetElement(cx, param, i, &elem_it)) {
				JS_Log(JS_LOG_ERR, "Failed to get the next element from array\n");
				free((*columns)->indexes);
				(*columns)->indexes = NULL;
				goto out_clean;
			}

			if (!JSVAL_IS_INT(elem_it)) {
				free((*columns)->indexes);
				(*columns)->indexes = NULL;
				JS_Log(JS_LOG_WARNING, "Inconsistent type of arguments\n");
				goto out_clean;
			}
			(*columns)->indexes[i] = JSVAL_TO_INT(elem_it);
		}
	} else if (JSVAL_IS_STRING(elem_it)) {
		(*columns)->names = malloc(len * sizeof(char *));
		if ((*columns)->names == NULL) {
			JS_Log(JS_LOG_ERR, "Failed to allocate memory\n");
			goto out;
		}
		(*columns)->indexes = NULL;

		for (i = 0; i < len; i++) {
			if (!JS_GetElement(cx, param, i, &elem_it)) {
				JS_Log(JS_LOG_ERR, "Failed to get the next element from array\n");
				free((*columns)->names);
				(*columns)->names = NULL;
				goto out_clean;
			}

			if (!JSVAL_IS_STRING(elem_it)) {
				unsigned int j;
				for (j = 0; j < i; j++) {
					free((*columns)->names[j]);
					(*columns)->names[j] = NULL;
				}
				free((*columns)->names);
				(*columns)->names = NULL;
				JS_Log(JS_LOG_WARNING, "Inconsistent type of arguments\n");
				goto out_clean;
			}

			char *value = JS_EncodeStringValue(cx, elem_it);
			(*columns)->names[i] = malloc (strlen(value) * sizeof(char));
			if ((*columns)->names[i] == NULL) {
				JS_Log(JS_LOG_WARNING, "Failed to allocate memory\n");
				free(value);
				unsigned int j;
				for (j = 0; j < i; j++) {
					free((*columns)->names[j]);
					(*columns)->names[j] = NULL;
				}
				free((*columns)->names);
				(*columns)->names = NULL;
				goto out_clean;
			}
			strcpy((*columns)->names[i], value);
			free(value);
		}
	} else {
		JS_Log(JS_LOG_INFO, "Wrong type of arguments\n");
		goto out_clean;
	}

	return JS_TRUE;

out_clean:
	free(*columns);
	*columns = NULL;
out:
	return JS_FALSE;
}

/**
 * Pgsql_setStatement - Creates a new statement using the SQL command and saves
 * it in the Statement's objects properties.
 * @cx: the JavaScript context
 * @argc: arguments number
 * @vp: return value
 * @obj: the instance of object on which the statement is set
 *
 * Returns JS_TRUE on success and JS_FALSE on failure
 */
static JSBool
Pgsql_setStatement(JSContext *cx, unsigned argc, jsval *vp, jsval obj)
{
	JSBool ret = JS_TRUE;
	jsval nativeSQL_argv[] = {JS_ARGV(cx, vp)[0]};
	jsval nativeSQL_jsv;
	jsval conn;
	int autoGeneratedKeys = NO_GENERATED_KEYS;
	struct agk_columns *columns = NULL;

	if (!JS_CallFunctionName(cx, JSVAL_TO_OBJECT(obj), "getConnection",
				argc, vp, &conn)) {
		ret = JS_FALSE;
		JS_Log(JS_LOG_ERR, "Failed to call getConnection\n");
		goto out;
	}

	if (JSVAL_IS_NULL(conn)) {
		ret = JS_FALSE;
		JS_Log(JS_LOG_ERR, "NULL Connection\n");
		goto out;
	}

	if (!JS_CallFunctionName(cx, JSVAL_TO_OBJECT(conn), "nativeSQL", 1,
				nativeSQL_argv, &nativeSQL_jsv)) {
		ret = JS_FALSE;
		JS_Log(JS_LOG_ERR, "Failed to call nativeSQL\n");
		goto out;
	}

	if (argc == 2) {
		if (JSVAL_IS_PRIMITIVE(JS_ARGV(cx, vp)[1])) {
			jsval second_param = JS_ARGV(cx, vp)[1];

			if ((JSVAL_IS_INT(second_param) && JSVAL_TO_INT(second_param) == 1) ||
					(JSVAL_IS_BOOLEAN(second_param) && JSVAL_TO_BOOLEAN(second_param) == JS_TRUE)) {
				autoGeneratedKeys = RETURN_GENERATED_KEYS;
			} else {
				JS_Log(JS_LOG_ERR, "The second parameters is incorrect\n");
			}
		} else {
			if (get_columns_values(cx, vp, &columns) == JS_FALSE)
				JS_Log(JS_LOG_ERR, "Failed to extract column names/indexes\n");
			else
				autoGeneratedKeys = RETURN_GENERATED_KEYS;
		}

	}

	struct statement *stmt = generate_statement(cx, nativeSQL_jsv, autoGeneratedKeys);
	if (stmt == NULL) {
		ret = JS_FALSE;
		JS_Log(JS_LOG_ERR, "Failed to generate the statement\n");
		goto out;
	}

	stmt->columns = columns;
	stmt->conn = (PGconn *)JS_GetPrivate(JSVAL_TO_OBJECT(conn));
	if (PQstatus(stmt->conn) != CONNECTION_OK) {
		JS_Log(JS_LOG_ERR, "Wrong connection status %s\n", PQerrorMessage(stmt->conn));
		clear_statement(stmt);
		ret = JS_FALSE;
		goto out;
	}

	JS_SetPrivate(JSVAL_TO_OBJECT(obj), stmt);
out:
	return ret;
}

/**
 * execute_statement - generic function for statement's execution
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 * @stmt: statement
 *
 * Returns JS_TRUE on success and JS_FALSE on failure.
 */
static JSBool
execute_statement(JSContext *cx, unsigned argc, jsval *vp, struct statement *stmt)
{
	if (stmt == NULL) {
		JS_Log(JS_LOG_WARNING, "NULL STATEMENT...\n");
		return JS_FALSE;
	}

	//if there is an old result clear the memory
	if (stmt->result) {
		PQclear(stmt->result);
		stmt->result = NULL;
	}

	if (argc == 1 && stmt->type != SIMPLE_STATEMENT) {
		JS_Log(JS_LOG_INFO, "Wrong statement type! You should use prepared statement\n");
		clear_statement(stmt);
		return JS_FALSE;
	} else if (argc == 0 && stmt->type != PREPARED_STATEMENT) {
		JS_Log(JS_LOG_INFO, "Wrong statement type! You should use simple statement\n");
		clear_statement(stmt);
		return JS_FALSE;
	}

	stmt->result = PQexecParams(stmt->conn,
			stmt->command,
			stmt->p_len,	/* parameters' length */
			NULL,		/* let the backend deduce param type */
			(const char **)stmt->p_values,
			NULL,		/* don't need param lengths since text */
			NULL,		/* default to all text params */
			TEXT_RESULT);	/* ask for text results */

	if (PQresultStatus(stmt->result) != PGRES_COMMAND_OK &&
			PQresultStatus(stmt->result) != PGRES_TUPLES_OK) {
		JS_Log(JS_LOG_ERR, "%s command failed: %s\n",
				stmt->command, PQerrorMessage(stmt->conn));
		clear_statement(stmt);
		//PQfinish(stmt->conn);
		return JS_FALSE;
	}

	return JS_TRUE;
}

/**
 * PgsqlStatement_execute - Executes the given SQL statement,
 * which may return multiple results. It returns false on error or
 * true on success.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns JS_TRUE on success and JS_FALSE on failure.
 */
static JSBool PgsqlStatement_execute(JSContext *cx, unsigned argc, jsval *vp)
{
	JSBool ret = JS_TRUE;
	/* if it is a simple statement set the SQL command*/
	jsval this = JS_THIS(cx, vp);

	if (argc < 0 || argc > 2) {
		JS_Log(JS_LOG_WARNING, "Wrong number of arguments\n");
		ret = JS_FALSE;
		goto out;
	}

	if (argc > 0) {
		/* if there is an old statement clear the memory */
		struct statement *stmt =
			(struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));
		if (stmt)
			clear_statement(stmt);

		if (Pgsql_setStatement(cx, argc, vp, this) == JS_FALSE) {
			ret = JS_FALSE;
			goto out;
		}
	}

	struct statement *stmt =
		(struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));
	if (stmt == NULL) {
		ret = JS_FALSE;
		goto out;
	}

	ret = execute_statement(cx, argc, vp, stmt);

out:
	JS_SET_RVAL(cx, vp, BOOLEAN_TO_JSVAL(ret));
	return JS_TRUE;
}

/**
 * PgsqlStatement_executeQuery - Executes the given SQL statement,
 * which returns a single result. On error returns NULL.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns JS_TRUE on success and JS_FALSE on failure and saves the ResultSet in vp.
 */
static JSBool
PgsqlStatement_executeQuery(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval this = JS_THIS(cx, vp);

	/* if it is a simple statement set the SQL command*/
	if (argc == 1) {
		/* if there is an old statement clear the memory */
		struct statement *stmt =
			(struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));
		if (stmt)
			clear_statement(stmt);

		if (Pgsql_setStatement(cx, argc, vp, this) == JS_FALSE) {
			goto out;
		}
	}

	struct statement *stmt =
		(struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));

	if (stmt == NULL)
		goto out;

	if (execute_statement(cx, argc, vp, stmt) == JS_FALSE) {
		if(stmt)
			clear_statement(stmt);
		goto out;
	}

	if (statement_get_result_set(cx, stmt, &JS_RVAL(cx, vp)) == JS_FALSE)
		goto out;

	return JS_TRUE;

out:
	JS_SET_RVAL(cx, vp, JSVAL_NULL);
	return JS_TRUE;
}

/**
 * PgsqlStatement_executeUpdate - Executes the given SQL statement, which may
 * be an INSERT, UPDATE, or DELETE statement or an SQL statement that returns
 * nothing, such as an SQL DDL statement. On error returns -1.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns JS_TRUE on success and JS_FALSE on failure and saves the affected
 * rows number in vp.
 */
static JSBool
PgsqlStatement_executeUpdate(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval this = JS_THIS(cx, vp);
	jsval rval = JS_NumberValue(-1);

	if (argc < 0 || argc > 2) {
		JS_Log(JS_LOG_WARNING, "Wrong number of arguments\n");
		goto out;
	}

	/* if it is a simple statement set the SQL command*/
	if (argc > 0) {
		/* if there is an old statement clear the memory */
		struct statement *stmt =
			(struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));
		if (stmt)
			clear_statement(stmt);

		if (Pgsql_setStatement(cx, argc, vp, this) == JS_FALSE) {
			goto out;
		}
	}

	struct statement *stmt =
		(struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));
	if (stmt == NULL)
		goto out;

	if (execute_statement(cx, argc, vp, stmt) == JS_FALSE) {
		if (stmt)
			clear_statement(stmt);
		goto out;
	}

	rval = JS_NumberValue(atoi(PQcmdTuples(stmt->result)));

out:
	JS_SET_RVAL(cx, vp, rval);
	return JS_TRUE;
}

/**
 * PgsqlStatement_getConnection - Executes the given SQL statement,
 * which may return multiple results.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns JS_TRUE on success and JS_FALSE on failure
 */
static JSBool
PgsqlStatement_getConnection(JSContext *cx, unsigned argc, jsval *vp)
{
	return getConnection(cx, vp);
}

/**
 * PgsqlStatement_getGeneratedKeys - Returns the generated keys
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 */
static JSBool
PgsqlStatement_getGeneratedKeys(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval this = JS_THIS(cx, vp);

	struct statement *stmt =
		(struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));

	if (stmt == NULL)
		goto out;

	if (stmt->autoGeneratedKeys != RETURN_GENERATED_KEYS) {
		JS_Log(JS_LOG_ERR, "You should specify the autoGeneratedKeys parameter\n");
		goto out;
	}

	if (statement_get_result_set(cx, stmt, &JS_RVAL(cx, vp)) == JS_FALSE)
		goto out;

	return JS_TRUE;

out:
	JS_SET_RVAL(cx, vp, JSVAL_NULL);
	return JS_TRUE;
}

/**
 * PgsqlStatement_getResultSet - Returns the result set
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 */
static JSBool
PgsqlStatement_getResultSet(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval this = JS_THIS(cx, vp);

	struct statement *stmt =
		(struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));

	if (stmt == NULL)
		goto out;

	if (statement_get_result_set(cx, stmt, &JS_RVAL(cx, vp)) == JS_FALSE)
		goto out;

	return JS_TRUE;

out:
	JS_SET_RVAL(cx, vp, JSVAL_NULL);
	return JS_TRUE;
}

/**
 * PgsqlStatement_getUpdateCount - Returns the number of updated rows
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 */
static JSBool
PgsqlStatement_getUpdateCount(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval rval = JS_NumberValue(-1);
	jsval this = JS_THIS(cx, vp);

	struct statement *stmt =
		(struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));

	if (stmt == NULL || stmt->result == NULL)
		goto out;

	rval = JS_NumberValue(atoi(PQcmdTuples(stmt->result)));

out:
	JS_SET_RVAL(cx, vp, rval);
	return JS_TRUE;
}

/**
 * PgsqlStatement_finalize - cleanup function for Statement objects
 * @cx: JavaScript context
 * @obj: object
 */
static void PgsqlStatement_finalize(JSFreeOp *fop, JSObject *obj)
{
	struct statement *stmt = (struct statement *)JS_GetPrivate(obj);

	if (stmt != NULL)
		clear_statement(stmt);
}

static JSFunctionSpec PgsqlStatement_functions[] = {
	JS_FS("execute", PgsqlStatement_execute, 2, 0),
	JS_FS("executeQuery", PgsqlStatement_executeQuery, 1, 0),
	JS_FS("executeUpdate", PgsqlStatement_executeUpdate, 2, 0),
	JS_FS("getConnection", PgsqlStatement_getConnection, 0, 0),
	JS_FS("getGeneratedKeys", PgsqlStatement_getGeneratedKeys, 0, 0),
	JS_FS("getResultSet", PgsqlStatement_getResultSet, 0, 0),
	JS_FS("getUpdateCount", PgsqlStatement_getUpdateCount, 0, 0),
	JS_FS_END
};

static JSClass PgsqlStatement_class = {
	"PgsqlStatement",		//name of the class
	JSCLASS_HAS_PRIVATE,		//flags
	JS_PropertyStub,		//addProperty (default value JS_PropertyStrub)
	JS_PropertyStub,		//delProperty (default)
	JS_PropertyStub,		//getProperty (default)
	JS_StrictPropertyStub,		//setProperty (default value JS_StrictPropertyStub)
	JS_EnumerateStub,		//enumerate (default)
	JS_ResolveStub,			//resolve -lazy properties(default)
	JS_ConvertStub,			//conversion to primitive value (default)
	PgsqlStatement_finalize,	//cleanup
};

/**
 * PgsqlPreparedStatement_set - Generic set parameter function
 * which may return multiple results.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns JS_TRUE on success and JS_FALSE on failure.
 */
static inline JSBool
PgsqlPreparedStatement_set(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval this = JS_THIS(cx, vp);
	struct statement *stmt = (struct statement *)JS_GetPrivate(JSVAL_TO_OBJECT(this));
	JSBool ret = JS_TRUE;
	int pos;

	if (stmt == NULL) {
		JS_Log(JS_LOG_ERR, "The statement property is not set\n");
		ret = JS_FALSE;
		goto out;
	}

	if (argc < 1) {
		JS_Log(JS_LOG_WARNING, "Wrong number of arguments\n");
		ret = JS_FALSE;
		goto out;
	}

	if (!JSVAL_IS_INT(JS_ARGV(cx, vp)[0])) {
		JS_Log(JS_LOG_WARNING, "The first parameter should be a number \
				which represents the position of the parameter\n");
		ret = JS_FALSE;
		goto out;
	}

	pos = JSVAL_TO_INT(JS_ARGV(cx, vp)[0]);

	if ( pos > stmt->p_len || pos < 1) {
		JS_Log(JS_LOG_WARNING, "The position is incorrect!\n");
		ret = JS_FALSE;
		goto out;
	}

	pos--;

	if (stmt->p_values[pos] != NULL) {
		JS_Log(JS_LOG_INFO, "The element from position %d was already set : %s.\n", pos + 1, stmt->p_values[pos] );
		free(stmt->p_values[pos]);
		stmt->p_values[pos] = NULL;
	}

	//if the parameter is NULL, let the value to remain NULL
	if (argc < 2 || JSVAL_IS_NULL(JS_ARGV(cx, vp)[1])) {
		stmt->p_values[pos] = NULL;
	} else {
		char *value = JS_EncodeStringValue(cx, JS_ARGV(cx, vp)[1]);
		stmt->p_values[pos] = malloc (strlen(value) * sizeof(char));
		if (stmt->p_values[pos] == NULL) {
			JS_Log(JS_LOG_WARNING, "Failed to allocate memory\n");
			ret = JS_FALSE;
			free(value);
			goto out;
		}
		strcpy(stmt->p_values[pos], value);
		free(value);
	}

out:
	JS_SET_RVAL(cx, vp, JSVAL_NULL);
	return ret;
}

/**
 * PgsqlPreparedStatement_execute - Executes the given SQL statement,
 * which may return multiple results.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns JS_TRUE on success and JS_FALSE on failure.
 */
static JSBool
PgsqlPreparedStatement_setNumber(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval ret = JSVAL_TRUE;

	if (!JSVAL_IS_NUMBER(JS_ARGV(cx, vp)[1]) ||
			JSVAL_IS_NULL(JS_ARGV(cx, vp)[1])) {
		JS_Log(JS_LOG_WARNING, "The value is not a number!\n");
		ret = JSVAL_FALSE;
		goto out;
	}

	ret = BOOLEAN_TO_JSVAL(PgsqlPreparedStatement_set(cx, argc, vp));

out:
	JS_SET_RVAL(cx, vp, ret);
	return JS_TRUE;
}

/**
 * PgsqlPreparedStatement_execute - Executes the given SQL statement,
 * which may return multiple results.
 * @cx: JavaScript context
 * @argc: arguments' number
 * @vp: arguments' values
 *
 * Returns JS_TRUE on success and JS_FALSE on failure.
 */
static JSBool
PgsqlPreparedStatement_setString(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval ret = JSVAL_TRUE;

	if (!JSVAL_IS_STRING(JS_ARGV(cx, vp)[1]) ||
			JSVAL_IS_NULL(JS_ARGV(cx, vp)[1])) {
		JS_Log(JS_LOG_WARNING, "The value is not a string!\n");
		ret = JSVAL_FALSE;
		goto out;
	}

	ret = BOOLEAN_TO_JSVAL(PgsqlPreparedStatement_set(cx, argc, vp));

out:
	JS_SET_RVAL(cx, vp, ret);
	return JS_TRUE;
}

static JSFunctionSpec PgsqlPreparedStatement_functions[] = {
	JS_FS("execute", PgsqlStatement_execute, 0, 0),
	JS_FS("executeQuery", PgsqlStatement_executeQuery, 0, 0),
	JS_FS("executeUpdate", PgsqlStatement_executeUpdate, 0, 0),
	JS_FS("getConnection", PgsqlStatement_getConnection, 0, 0),
	JS_FS("getGeneratedKeys", PgsqlStatement_getGeneratedKeys, 0, 0),
	JS_FS("getResultSet", PgsqlStatement_getResultSet, 0, 0),
	JS_FS("getUpdateCount", PgsqlStatement_getUpdateCount, 0, 0),
	JS_FS("setNumber", PgsqlPreparedStatement_setNumber, 2, 0),
	JS_FS("setString", PgsqlPreparedStatement_setString, 2, 0),
	JS_FS_END
};

static JSClass PgsqlPreparedStatement_class = {
	"PgsqlPreparedStatement",	//name of the class
	JSCLASS_HAS_PRIVATE,		//flags
	JS_PropertyStub,		//addProperty (default value JS_PropertyStrub)
	JS_PropertyStub,		//delProperty (default)
	JS_PropertyStub,		//getProperty (default)
	JS_StrictPropertyStub,		//setProperty (default value JS_StrictPropertyStub)
	JS_EnumerateStub,		//enumerate (default)
	JS_ResolveStub,			//resolve -lazy properties(default)
	JS_ConvertStub,			//conversion to primitive value (default)
	PgsqlStatement_finalize,	//cleanup
};

/**
 * PgsqlConnection_createStatement - Used to create a Statement object
 * @cx: JavaScript context
 * @argc: number of argumets
 * @vp: arguments array
 *
 * Returns JS_TRUE on success and JS_FALSE on failure.
 */
static JSBool
PgsqlConnection_createStatement(JSContext *cx, unsigned argc, jsval *vp)
{
	return createStatement(cx, vp, &PgsqlStatement_class,
			PgsqlStatement_functions);
}

/**
 * PgsqlConnection_prepareStatement - Used to create a PreparedStatement
 * object.
 * @cx: JavaScript context
 * @argc: number of argumets
 * @vp: arguments array
 *
 * Returns JS_TRUE on success and JS_FALSE on failure.
 */
static JSBool
PgsqlConnection_prepareStatement(JSContext *cx, unsigned argc, jsval *vp)
{
	jsval rval = JSVAL_NULL;

	if (argc < 1 || argc > 2) {
		JS_Log(JS_LOG_WARNING, "Wrong number of arguments\n");
		goto out;
	}

	JSObject *obj = JS_NewObject(cx, &PgsqlPreparedStatement_class, NULL, NULL);
	if (obj == NULL) {
		JS_ReportError(cx, "Failed to create a new object\n");
		JS_Log(JS_LOG_ERR, "Failed to create a new object\n");
		goto out;
	}

	JS_DefineProperty(cx, obj, "connection",
			JS_THIS(cx, vp), NULL, NULL,
			JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT);

	if (JS_DefineFunctions(cx, obj, PgsqlPreparedStatement_functions) == JS_FALSE) {
		JS_ReportError(cx, "Failed to define functions in createStatement\n");
		JS_Log(JS_LOG_ERR, "Failed to define functions in createStatement\n");
		goto out;
	}

	if (Pgsql_setStatement(cx, argc, vp, OBJECT_TO_JSVAL(obj)) == JS_FALSE)
		goto out;

	rval = OBJECT_TO_JSVAL(obj);

out:
	JS_SET_RVAL(cx, vp, rval);
	return JS_TRUE;
}

/**
 * PgsqlConnection_nativeSQL - Used to convert SQL commands to native SQL
 * @cx: JavaScript context
 * @argc: number of argumets
 * @vp: arguments array
 *
 * Returns JS_TRUE on success and JS_FALSE on failure and saves the converted
 * value to vp.
 */
static JSBool
PgsqlConnection_nativeSQL(JSContext *cx, unsigned argc, jsval *vp)
{
	return nativeSQL(cx, argc, vp);
}

/**
 * PgsqlConnection_finalize - cleanup function for Connection objects
 * @cx: JavaScript context
 * @obj: object
 */
static void PgsqlConnection_finalize(JSFreeOp *fop, JSObject *obj)
{
	PGconn *conn = (PGconn *)JS_GetPrivate(obj);

	if (conn != NULL)
		PQfinish(conn);
}

static JSFunctionSpec PgsqlConnection_functions[] = {
	JS_FS("createStatement", PgsqlConnection_createStatement, 0, 0),
	JS_FS("prepareStatement", PgsqlConnection_prepareStatement, 2, 0),
	JS_FS("nativeSQL", PgsqlConnection_nativeSQL, 1, 0),
	JS_FS_END
};

static JSClass PgsqlConnection_class = {
	"PgsqlConnection",		//name of the class
	JSCLASS_HAS_PRIVATE,		//flags
	JS_PropertyStub,		//addProperty (default value JS_PropertyStrub)
	JS_PropertyStub,		//delProperty (default)
	JS_PropertyStub,		//getProperty (default)
	JS_StrictPropertyStub,		//setProperty (default value JS_StrictPropertyStub)
	JS_EnumerateStub,		//enumerate (default)
	JS_ResolveStub,			//resolve -lazy properties(default)
	JS_ConvertStub,			//conversion to primitive value (default)
	PgsqlConnection_finalize,	//cleanup
};

/**
 * PgsqlDriver_acceptsURL - checks if the URL is a valid one
 * @cx: JavaScript context
 * @argc: number of argumets
 * @vp: arguments array
 *
 * Returns JS_TRUE on success and JS_FALSE on failure
 */
static JSBool PgsqlDriver_acceptsURL(JSContext * cx, unsigned argc, jsval * vp)
{
	char *url = JS_EncodeStringValue(cx, JS_ARGV(cx, vp)[0]);
	if (url == NULL) {
		JS_Log(JS_LOG_ERR, "Failed to convert the URL value to JSString\n");
		goto out;
	}

	JS_Log(JS_LOG_NOTICE, "Checking the PostgreSQL url: '%s'\t", url);

	if (strncmp(url, POSTGRES_URI, POSTGRES_URI_LEN)) {
		JS_SET_RVAL(cx, vp, JSVAL_FALSE);
		JS_Log(JS_LOG_NOTICE, "BAD url. It should start with %s\n", POSTGRES_URI);
	} else {
		JS_SET_RVAL(cx, vp, JSVAL_TRUE);
		JS_Log(JS_LOG_NOTICE, "GOOD url\n");
	}
	JS_free(cx, url);

	return JS_TRUE;

out:
	JS_SET_RVAL(cx, vp, JSVAL_FALSE);
	return JS_TRUE;
}

/**
 * PgsqlDriver_connect - driver's connection function
 * @cx: JavaScript context
 * @argc: number of argumets
 * @vp: arguments array
 *
 * Returns JS_TRUE on success and JS_FALSE on failure
 */
static JSBool PgsqlDriver_connect(JSContext * cx, unsigned argc, jsval * vp)
{
	JSBool ret = JS_TRUE;
	jsval rval = JSVAL_NULL;
	if (!argc)
		goto out;

	char *url = JS_EncodeStringValue(cx, JS_ARGV(cx, vp)[0]);
	if (url == NULL) {
		JS_ReportError(cx, "[PgsqlDriver_connect] Failed to convert the URL "
				"value to JSString\n");
		JS_Log(JS_LOG_ERR, "Failed to convert the URL value to JSString\n");
		goto out_clean;
	}

	if (strncmp(url, POSTGRES_URI, POSTGRES_URI_LEN)) {
		JS_ReportWarning(cx, "Invalid url. It should start with %s\n",
				POSTGRES_URI);
		JS_Log(JS_LOG_WARNING, "Invalid url. It should start with %s\n", POSTGRES_URI);
		goto out_clean;
	}

	char *host = url + POSTGRES_URI_LEN;
	unsigned int port = POSTGRES_DEFAULT_PORT;

	int sep_pos = strcspn(host, ":/");
	if (sep_pos == strlen(host))
		goto invalid_url;

	char *cursor = host + sep_pos;
	if (*cursor == ':') {
		char *port_str;
		*(cursor++) = '\0';
		port_str = cursor;
		int db_sep = strcspn(cursor, "/");

		if (db_sep == strlen(cursor))
			goto invalid_url;

		cursor += db_sep;
		*(cursor++) = '\0';
		port = atoi(port_str);
	} else if (*cursor == '/') {
		*(cursor++) = '\0';
	} else {
		goto invalid_url;
	}

	//TODO Move the common code in a separated source
	char *user = NULL, *passwd = NULL;
	if (argc > 1 && !JSVAL_IS_PRIMITIVE(JS_ARGV(cx, vp)[1]) &&
			!JSVAL_IS_NULL(JS_ARGV(cx, vp)[1])) {
		JSObject *info = JSVAL_TO_OBJECT(JS_ARGV(cx, vp)[1]);
		jsval user_jsv, passwd_jsv;

		if (JS_GetProperty(cx, info, "user", &user_jsv) &&
				!JSVAL_IS_NULL(user_jsv)) {
			JSString *user_str = JS_ValueToString(cx, user_jsv);
			user = JS_EncodeString(cx, user_str);
		}

		if (JS_GetProperty(cx, info, "password", &passwd_jsv) &&
				!JSVAL_IS_NULL(passwd_jsv)) {
			JSString *passwd_str = JS_ValueToString(cx, passwd_jsv);
			passwd = JS_EncodeString(cx, passwd_str);
		}
	}

	char postgres_connector[POSTGRES_CONNECTOR_LEN];
	sprintf(postgres_connector, "dbname=%s hostaddr=%s port=%d",
			cursor, host, port);

	if (user != NULL) {
		strcat(postgres_connector, " user=");
		strcat(postgres_connector, user);
		JS_free(cx, user);
	}

	if (passwd != NULL) {
		strcat(postgres_connector, " password=");
		strcat(postgres_connector, passwd);
		JS_free(cx, passwd);
	}

	PGconn *connection;
	connection = PQconnectdb(postgres_connector);
	if (PQstatus(connection) != CONNECTION_OK) {
		ret = JS_FALSE;
		JS_ReportError(cx, "Connection failed %s", PQerrorMessage(connection));
		JS_Log(JS_LOG_ERR, "Connection failed %s", PQerrorMessage(connection));
		PQfinish(connection);
		goto out_clean;
	}

	JSObject *retobj = JS_NewObject(cx, &PgsqlConnection_class, NULL, NULL);
	if (retobj == NULL) {
		ret = JS_FALSE;
		JS_ReportError(cx, "Failed to create a new object\n");
		JS_Log(JS_LOG_ERR, "Failed to create a new object\n");
		goto out_clean;
	}

	JS_SetPrivate(retobj, connection);
	if (JS_DefineFunctions(cx, retobj, PgsqlConnection_functions) == JS_FALSE) {
		ret = JS_FALSE;
		JS_ReportError(cx, "Failed to define functions for the PgsqlConnection "
				"class\n");
		JS_Log(JS_LOG_ERR, "Failed to define functions for the PgsqlConnection class\n");
		goto out_clean;
	}

	rval = OBJECT_TO_JSVAL(retobj);
	goto out_clean;

invalid_url:
	JS_ReportWarning(cx, "Invalid url. The database should be separated by '/'\n");
	JS_Log(JS_LOG_WARNING, "Invalid url. The database should be separated by '/'\n");
out_clean:
	JS_free(cx, url);
out:
	JS_SET_RVAL(cx, vp, rval);
	return ret;
}

static JSFunctionSpec PgsqlDriver_functions[] = {
	JS_FS("acceptsURL", PgsqlDriver_acceptsURL, 1, 0),
	JS_FS("connect", PgsqlDriver_connect, 2, 0),
	JS_FS_END
};

/**
 * JS_PgsqlConstructAndRegister - Constructs a JavaScript object which will
 * contain PostgreSql driver functions and register it.
 * @cx: JavaScript context
 * @global: global JavaScript object
 *
 * Returns JS_TRUE on success and JS_FALSE on failure
 */
JSBool JS_PgsqlConstructAndRegister(JSContext * cx, JSObject * global)
{
	JSObject *obj = JS_NewObject(cx, NULL, NULL, NULL);

	if (!JS_DefineFunctions(cx, obj, PgsqlDriver_functions))
		return JS_FALSE;

	return JS_SqlRegisterDriver(cx, global, obj);
}

#endif
